---
layout: post
title: Basic Primes in Scala
date: 2008-04-16 00:17:53.000000000 +12:00
categories:
- Scala
tags: []
status: publish
type: post
published: true
meta:
  _edit_last: '1832023'
author:
  login: spdenne
  email: stephen@datacute.co.nz
  display_name: Stephen Denne
  first_name: ''
  last_name: ''
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>I've started learning <a href="http://www.scala-lang.org/" target="_blank">Scala</a>. One way I learn is by reading and experimenting, so I looked for a simple program I could write in the right problem space to make use of language features expressed more succinctly in Scala than in Java. </p>
<p><!--more--></p>
<h3>Desired Application</h3>
<p>I chose to implement a weird idea that I had a couple of years ago: Instead of representing natural numbers in base 10, or any other fixed base, record the prime factorisation. Instead of recording how many 1s, 10s, 100s, 1000s, etc. to sum, you can record how many 2s, 3s, 5s, 7s, 11s, 13s, etc. to multiply. (With a special code for 1.) Each prime number is indexed, and referred to by its index, such that, for example the number 288 (base 10) = 3^2 x 2^5, which is 3 (the second prime) to the power of 2 (the first prime), multiplied by 2 (the first prime) to the power of 5 (the third prime). The powers are also converted into their representation within this same system.</p>
<p>Using [x] to refer to the x'th prime, we get 288 (base 10)</p>
<pre>= [2] ^ [1] x [1] ^ [3]
= [[1]] ^ [1] x [1] ^ [[2]]
= [[1]] ^ [1] x [1] ^ [[[1]]]</pre>
<p>Everything reduces to [1], which I then replace with []. Multiplication signs can be removed, and power signs can be replaced with parenthesis to give a cryptic representation: 288 = [[]]([])[]([[[]]])</p>
<p>A cleaner representation may be to replace 1, with (), meaning "to the power of zero", but that is not what I did for this silly example.</p>
<p>That covers the basic idea for the program: conversion from simple base 10 numbers into these cryptic character sequences representing the prime factorisation.</p>
<h3>Generating A Sequence Of Primes</h3>
<p>To start with I looked for a way to calculate primes in Scala. The docs on <a href="http://www.scala-lang.org/docu/files/api/scala/Stream.html" target="_blank">scala.Stream</a> includes a simple definition of the <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank">Sieve of Eratosthenes</a>. I started with something similar, which I found on <a href="http://www.scala-kurz.org/show/15" target="_blank">Scala Kurz</a>:</p>
<pre><span style="color:#7f7f7f;">def </span><span style="color:#1e90ff;">sieve</span>(<span style="color:#1b1bd7;">s</span>: <span style="color:brown;">Stream</span>[<span style="color:brown;">Int</span>]): <span style="color:brown;">Stream</span>[<span style="color:brown;">Int</span>] = 
<span style="color:brown;">  Stream</span>.<span style="color:brown;">cons</span>(<span style="color:#1b1bd7;">s</span>.<span style="color:#1e90ff;">head</span>, <span style="color:#1e90ff;">sieve</span>(<span style="color:#1b1bd7;">s</span>.<span style="color:#1e90ff;">tail filter </span>(_ <span style="color:#1e90ff;">% </span><span style="color:#1b1bd7;">s</span>.<span style="color:#1e90ff;">head != </span>0)))
<span style="color:#7f7f7f;">val </span><span style="color:#1b1bd7;">primes </span>= <span style="color:#1e90ff;">sieve</span>(<span style="color:brown;">Stream</span>.<span style="color:#1e90ff;">from</span>(2))
</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>This simple algorithm is quite easy to understand, but unfortunately is pretty useless, as it is so resource intensive that without changing any JVM runtime parameters, it can only calculate up to the 1641st prime (or the 3715th prime if using the scala runtime, which starts the jvm with a larger heap) before overflowing the stack.</p>
<h3>Generating A Sequence Of Primes Efficiently</h3>
<p>The <a href="http://en.literateprograms.org/LiteratePrograms:Welcome" target="_blank">Literate Programs site</a> includes the same implementation in its <a href="http://en.literateprograms.org/Sieve_of_Eratosthenes_%28Scala%29" target="_blank">Sieve of Eratosthenes in Scala</a> page, but the <a href="http://en.literateprograms.org/Sieve_of_Eratosthenes_%28Haskell%29" target="_blank">Sieve of Eratosthenes in Haskell</a> includes a more efficient functional implementation that I thought I'd convert to Scala (I don't know Haskell, but the algorithm is explained well).</p>
<p>The most difficult part of the conversion was trying to decipher what foldr1 was supposed to do. I incorrectly assumed it was the same as Stream.foldRight, which I butchered till I arrived at something that seemed to work (The definition of foldr1 below is probably <strong>not</strong> equivalent to Haskell's.):</p>
<pre><span style="color:#7f7f7f;">def </span><span style="color:#1e90ff;">merge</span>(<span style="color:#1b1bd7;">xs</span>: <span style="color:brown;">Stream</span>[<span style="color:brown;">Int</span>] , <span style="color:#1b1bd7;">ys</span>: <span style="color:brown;">Stream</span>[<span style="color:brown;">Int</span>]): <span style="color:brown;">Stream</span>[<span style="color:brown;">Int</span>] = {
  <span style="color:#7f7f7f;">if </span>(<span style="color:#1b1bd7;">xs</span>.<span style="color:#1e90ff;">head &lt; </span><span style="color:#1b1bd7;">ys</span>.<span style="color:#1e90ff;">head</span>)
    <span style="color:#7f7f7f;">return </span><span style="color:brown;">Stream</span>.<span style="color:brown;">cons</span>(<span style="color:#1b1bd7;">xs</span>.<span style="color:#1e90ff;">head</span>, <span style="color:#1e90ff;">merge</span>(<span style="color:#1b1bd7;">xs</span>.<span style="color:#1e90ff;">tail</span>, <span style="color:#1b1bd7;">ys</span>))
  <span style="color:#7f7f7f;">if </span>(<span style="color:#1b1bd7;">xs</span>.<span style="color:#1e90ff;">head == </span><span style="color:#1b1bd7;">ys</span>.<span style="color:#1e90ff;">head</span>) 
    <span style="color:#7f7f7f;">return </span><span style="color:brown;">Stream</span>.<span style="color:brown;">cons</span>(<span style="color:#1b1bd7;">xs</span>.<span style="color:#1e90ff;">head</span>, <span style="color:#1e90ff;">merge</span>(<span style="color:#1b1bd7;">xs</span>.<span style="color:#1e90ff;">tail</span>, <span style="color:#1b1bd7;">ys</span>.<span style="color:#1e90ff;">tail</span>))
  <span style="color:#7f7f7f;">return </span><span style="color:brown;">Stream</span>.<span style="color:brown;">cons</span>(<span style="color:#1b1bd7;">ys</span>.<span style="color:#1e90ff;">head</span>, <span style="color:#1e90ff;">merge</span>(<span style="color:#1b1bd7;">xs</span>, <span style="color:#1b1bd7;">ys</span>.<span style="color:#1e90ff;">tail</span>))
}
<span style="color:#7f7f7f;">def </span><span style="color:#1e90ff;">diff</span>(<span style="color:#1b1bd7;">xs</span>: <span style="color:brown;">Stream</span>[<span style="color:brown;">Int</span>], <span style="color:#1b1bd7;">ys</span>: <span style="color:brown;">Stream</span>[<span style="color:brown;">Int</span>]): <span style="color:brown;">Stream</span>[<span style="color:brown;">Int</span>] = {
  <span style="color:#7f7f7f;">if </span>(<span style="color:#1b1bd7;">xs</span>.<span style="color:#1e90ff;">head &lt; </span><span style="color:#1b1bd7;">ys</span>.<span style="color:#1e90ff;">head</span>) 
    <span style="color:#7f7f7f;">return </span><span style="color:brown;">Stream</span>.<span style="color:brown;">cons</span>(<span style="color:#1b1bd7;">xs</span>.<span style="color:#1e90ff;">head</span>, <span style="color:#1e90ff;">diff</span>(<span style="color:#1b1bd7;">xs</span>.<span style="color:#1e90ff;">tail</span>, <span style="color:#1b1bd7;">ys</span>))
  <span style="color:#7f7f7f;">if </span>(<span style="color:#1b1bd7;">xs</span>.<span style="color:#1e90ff;">head == </span><span style="color:#1b1bd7;">ys</span>.<span style="color:#1e90ff;">head</span>) <span style="color:#7f7f7f;">return </span><span style="color:#1e90ff;">diff</span>(<span style="color:#1b1bd7;">xs</span>.<span style="color:#1e90ff;">tail</span>, <span style="color:#1b1bd7;">ys</span>.<span style="color:#1e90ff;">tail</span>)
  <span style="color:#7f7f7f;">return </span><span style="color:#1e90ff;">diff</span>(<span style="color:#1b1bd7;">xs</span>, <span style="color:#1b1bd7;">ys</span>.<span style="color:#1e90ff;">tail</span>)
}
<span style="color:#7f7f7f;">def </span><span style="color:#1e90ff;">f</span>(<span style="color:#1b1bd7;">xs</span>: <span style="color:brown;">Stream</span>[<span style="color:brown;">Int</span>], <span style="color:#1b1bd7;">ys</span>: =&gt; <span style="color:brown;">Stream</span>[<span style="color:brown;">Int</span>]) = 
  <span style="color:brown;">Stream</span>.<span style="color:brown;">cons</span>(<span style="color:#1b1bd7;">xs</span>.<span style="color:#1e90ff;">head</span>, <span style="color:#1e90ff;">merge</span>(<span style="color:#1b1bd7;">xs</span>.<span style="color:#1e90ff;">tail</span>, <span style="color:#1b1bd7;">ys</span>))
<span style="color:#7f7f7f;">def </span><span style="color:#1e90ff;">g</span>(<span style="color:#1b1bd7;">p</span>: <span style="color:brown;">Int</span>) = <span style="color:brown;">Stream</span>.<span style="color:#1e90ff;">from</span>(<span style="color:#1b1bd7;">p</span><span style="color:#1e90ff;">*</span><span style="color:#1b1bd7;">p</span>,<span style="color:#1b1bd7;">p</span><span style="color:#1e90ff;">*</span>2)
<span style="color:#7f7f7f;">def </span><span style="color:#1e90ff;">foldr1</span>(<span style="color:#1b1bd7;">f</span>: (<span style="color:brown;">Stream</span>[<span style="color:brown;">Int</span>], =&gt; <span style="color:brown;">Stream</span>[<span style="color:brown;">Int</span>]) =&gt; <span style="color:brown;">Stream</span>[<span style="color:brown;">Int</span>])
  (<span style="color:#1b1bd7;">s</span>: <span style="color:brown;">Stream</span>[<span style="color:brown;">Stream</span>[<span style="color:brown;">Int</span>]]): <span style="color:brown;">Stream</span>[<span style="color:brown;">Int</span>] =
  <span style="color:#7f7f7f;">if </span>(<span style="color:#1b1bd7;">s</span>.<span style="color:#1e90ff;">isEmpty</span>) <span style="color:brown;">Stream</span>.<span style="color:#1e90ff;">empty
  </span><span style="color:#7f7f7f;">else </span><span style="color:#1b1bd7;">f</span>(<span style="color:#1b1bd7;">s</span>.<span style="color:#1e90ff;">head</span>, <span style="color:#1e90ff;">foldr1</span>(<span style="color:#1b1bd7;">f</span>)(<span style="color:#1b1bd7;">s</span>.<span style="color:#1e90ff;">tail</span>))
<span style="color:#7f7f7f;">val </span><span style="color:#1b1bd7;">primes</span>: <span style="color:brown;">Stream</span>[<span style="color:brown;">Int</span>] = 
  <span style="color:brown;">Stream</span>.<span style="color:#1e90ff;">fromIterator</span>((2<span style="color:#1e90ff;">::</span>3<span style="color:#1e90ff;">::</span>5<span style="color:#1e90ff;">::</span><span style="color:brown;">Nil</span>).<span style="color:#1e90ff;">elements</span>).<span style="color:#1e90ff;">append</span>(
      <span style="color:#1e90ff;">diff</span>(<span style="color:brown;">Stream</span>.<span style="color:#1e90ff;">from</span>(7,2), <span style="color:#1e90ff;">nonprimes</span>))
<span style="color:#7f7f7f;">val </span><span style="color:#1b1bd7;">nonprimes </span>= <span style="color:#1e90ff;">foldr1</span>(<span style="color:#1e90ff;">f</span>)(<span style="color:#1e90ff;">primes</span>.<span style="color:#1e90ff;">tail map g</span>)</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>Now I can calculate up to the 18707th prime, an order of magnitude more that the simple algorithm, in an order of magnitude more lines of code.</p>
<p>Comments in Jorge Ortiz post <a href="http://scala-blogs.org/2007/12/project-euler-fun-in-scala.html" target="_blank">Fun with Project Euler and Scala</a> also mention the poor resource utilisation of the two-line sieve, and code is supplied for providing a stream of primes using java's BigInteger.nextProbablePrime(). I'll leave that for now though, and get back on track...</p>
<h3>Determining Prime Factorisation</h3>
<p>Next I needed indexed prime factors:</p>
<pre><span style="color:#7f7f7f;">// Prime Factor Tuple: Prime, Power, Index
</span><span style="color:#7f7f7f;">type </span><span style="color:#8b6914;">Factors </span>= <span style="color:brown;">List</span>[(<span style="color:brown;">Int</span>, <span style="color:brown;">Int</span>, <span style="color:brown;">Int</span>)];
<span style="color:#7f7f7f;">def </span><span style="color:#1e90ff;">primeFactorsRecurse</span>(<span style="color:#1b1bd7;">i</span>: <span style="color:brown;">Int</span>, <span style="color:#1b1bd7;">factors</span>: <span style="color:#8b6914;">Factors</span>, 
    <span style="color:#1b1bd7;">morePrimes</span>: <span style="color:brown;">Stream</span>[<span style="color:brown;">Int</span>], <span style="color:#1b1bd7;">index</span>: <span style="color:brown;">Int</span>): <span style="color:#8b6914;">Factors </span>= {
  <span style="color:#7f7f7f;">if </span>(<span style="color:#1b1bd7;">i </span><span style="color:#1e90ff;">== </span>1) <span style="color:#7f7f7f;">return </span><span style="color:#1b1bd7;">factors</span>;
  <span style="color:#7f7f7f;">if </span>(<span style="color:#1b1bd7;">i </span><span style="color:#1e90ff;">% </span><span style="color:#1b1bd7;">morePrimes</span>.<span style="color:#1e90ff;">head == </span>0) {
    <span style="color:#7f7f7f;">if </span>((<span style="color:#1b1bd7;">factors </span><span style="color:#1e90ff;">!= </span><span style="color:brown;">Nil</span>) <span style="color:#1e90ff;">&amp;&amp; </span>(<span style="color:#1b1bd7;">morePrimes</span>.<span style="color:#1e90ff;">head == </span><span style="color:#1b1bd7;">factors</span>.<span style="color:#1e90ff;">head</span>.<span style="color:#1e90ff;">_1</span>)) {
      <span style="color:#7f7f7f;">return </span><span style="color:#1e90ff;">primeFactorsRecurse</span>(<span style="color:#1b1bd7;">i </span><span style="color:#1e90ff;">/ </span><span style="color:#1b1bd7;">morePrimes</span>.<span style="color:#1e90ff;">head</span>, 
          (<span style="color:#1b1bd7;">morePrimes</span>.<span style="color:#1e90ff;">head</span>, <span style="color:#1b1bd7;">factors</span>.<span style="color:#1e90ff;">head</span>.<span style="color:#1e90ff;">_2 + </span>1, <span style="color:#1b1bd7;">index</span>) <span style="color:#1e90ff;">:: 
          </span><span style="color:#1b1bd7;">factors</span>.<span style="color:#1e90ff;">tail</span>, 
          <span style="color:#1b1bd7;">morePrimes</span>, <span style="color:#1b1bd7;">index</span>);
    } <span style="color:#7f7f7f;">else </span>{
      <span style="color:#7f7f7f;">return </span><span style="color:#1e90ff;">primeFactorsRecurse</span>(<span style="color:#1b1bd7;">i </span><span style="color:#1e90ff;">/ </span><span style="color:#1b1bd7;">morePrimes</span>.<span style="color:#1e90ff;">head</span>, 
          (<span style="color:#1b1bd7;">morePrimes</span>.<span style="color:#1e90ff;">head</span>, 1, <span style="color:#1b1bd7;">index</span>) <span style="color:#1e90ff;">:: </span><span style="color:#1b1bd7;">factors</span>, 
          <span style="color:#1b1bd7;">morePrimes</span>, <span style="color:#1b1bd7;">index</span>);
    }
  }
  <span style="color:#7f7f7f;">return </span><span style="color:#1e90ff;">primeFactorsRecurse</span>(
      <span style="color:#1b1bd7;">i</span>, <span style="color:#1b1bd7;">factors</span>, <span style="color:#1b1bd7;">morePrimes </span><span style="color:#1e90ff;">drop </span>1, <span style="color:#1b1bd7;">index </span><span style="color:#1e90ff;">+ </span>1);
}

<span style="color:#7f7f7f;">def </span><span style="color:#1e90ff;">primeFactors</span>(<span style="color:#1b1bd7;">i</span>: <span style="color:brown;">Int</span>): <span style="color:#8b6914;">Factors </span>= {
  <span style="color:#7f7f7f;">if </span>(<span style="color:#1b1bd7;">i </span><span style="color:#1e90ff;">== </span>1) <span style="color:#7f7f7f;">return </span>(1,1,0) <span style="color:#1e90ff;">:: </span><span style="color:brown;">Nil</span>;
  <span style="color:#1e90ff;">primeFactorsRecurse</span>(<span style="color:#1b1bd7;">i</span>, <span style="color:brown;">Nil</span>, <span style="color:#1e90ff;">primes</span>, 1);
}</pre>
<p><a href="http://11011.net/software/vspaste"></a><a href="http://11011.net/software/vspaste"></a><a href="http://11011.net/software/vspaste"></a></p>
<h3>Printing The Numbers</h3>
<p>All that is needed now is the code to print the numbers using the unusual representation described above:</p>
<pre><span style="color:#7f7f7f;">def </span><span style="color:#1e90ff;">printPrimeFactors</span>(<span style="color:#1b1bd7;">factors</span>: <span style="color:#8b6914;">Factors</span>): <span style="color:brown;">Unit </span>= {
  <span style="color:#1b1bd7;">factors </span><span style="color:#7f7f7f;">match</span>{
    <span style="color:#7f7f7f;">case </span>(<span style="color:#1b1bd7;">prime</span>: <span style="color:brown;">Int</span>, <span style="color:#1b1bd7;">power</span>: <span style="color:brown;">Int</span>, <span style="color:#1b1bd7;">index</span>: <span style="color:brown;">Int</span>) <span style="color:brown;">:: </span><span style="color:#1b1bd7;">morefactors </span>=&gt;  {
      <span style="color:#7f7f7f;">if </span>(<span style="color:#1b1bd7;">index </span><span style="color:#1e90ff;">&gt; </span>0) <span style="color:#1e90ff;">printPrimeFactors</span>(<span style="color:#7f7f7f;">"["</span>, <span style="color:#1b1bd7;">index</span>, <span style="color:#7f7f7f;">"]"</span>)
      <span style="color:#7f7f7f;">if </span>(<span style="color:#1b1bd7;">power </span><span style="color:#1e90ff;">&gt; </span>1) <span style="color:#1e90ff;">printPrimeFactors</span>(<span style="color:#7f7f7f;">"("</span>, <span style="color:#1b1bd7;">power</span>, <span style="color:#7f7f7f;">")"</span>)
      <span style="color:#1e90ff;">printPrimeFactors</span>(<span style="color:#1b1bd7;">morefactors</span>)
    }
    <span style="color:#7f7f7f;">case </span><span style="color:brown;">Nil </span>=&gt; ();
  }
}

<span style="color:#7f7f7f;">def </span><span style="color:#1e90ff;">printPrimeFactors</span>(<span style="color:#1b1bd7;">pre</span>: <span style="color:brown;">String</span>, <span style="color:#1b1bd7;">i</span>: <span style="color:brown;">Int</span>, <span style="color:#1b1bd7;">post</span>: <span style="color:brown;">String</span>): <span style="color:brown;">Unit </span>= {
  <span style="color:#1e90ff;">print</span>(<span style="color:#1b1bd7;">pre</span>)
  <span style="color:#1e90ff;">printPrimeFactors</span>(<span style="color:#1e90ff;">primeFactors</span>(<span style="color:#1b1bd7;">i</span>))
  <span style="color:#1e90ff;">print</span>(<span style="color:#1b1bd7;">post</span>)
}

(1 <span style="color:#1e90ff;">to </span>300) <span style="color:#1e90ff;">foreach </span>{<span style="color:#1b1bd7;">i</span>: <span style="color:brown;">Int </span>=&gt; <span style="color:#1e90ff;">printPrimeFactors</span>(<span style="color:#1b1bd7;">i </span><span style="color:#1e90ff;">+ </span><span style="color:#7f7f7f;">":"</span>,<span style="color:#1b1bd7;">i</span>,<span style="color:#7f7f7f;">"\n"</span>)}</pre></p>
<h3>Summary</h3>
<p>I was able to create an application in Scala to do what I wanted, while making use of a number of Scala language features.</p>
<p>I'll welcome corrections, and comments regarding the Scala code, such as how I can create a infix Stream.cons operator to make my code less verbose, or ways to automatically switch to BigInts if the range of Int is surpassed.</p>
<p>I'd also be extremely interested in anyone can think of a use for this representation of natural numbers. The same ideas can be converted into graphical symbols, e.g. using differently sized concentric circles instead of [[[]]], or tracing a path to give a particular "primal squiggle" that uniquely represents a number, (such as an IP address). The order of factors doesn't matter, so that provides scope to position graphical representations of them in artistically pleasing arrangements.</p>
